/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_simple_adaptive_slider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/simple-adaptive-slider.js */ \"./src/js/modules/simple-adaptive-slider.js\");\n\r\n\r\n// flsFunctions.isWebp();\r\n\r\n\r\n// слайдер\r\n\r\n// import Swiper, { Navigation, Pagination } from 'swiper';\r\n\r\n// Swiper.use([Navigation, Pagination]);\r\n// или же можем подключить и активировать сразу все модули. Но они весят очень много!!!\r\n// import Swiper from 'swiper/bundle';\r\n// Swiper.use();\r\n\r\n// const swiper = new Swiper('.swiper', {\r\n\r\n//     navigation: {\r\n//         nextEl: '.swiper-button-next',\r\n//         prevEl: '.swiper-button-prev'\r\n//     },\r\n\r\n//     slidesPerView: 2,\r\n// });\r\n\r\n//! адаптивное меню\r\n\r\ntry {\r\n    const menuIcon = document.querySelector('.menu__icon');\r\n    const headerMenu = document.querySelector('.menu__row');\r\n\r\n    menuIcon.addEventListener('click', () => {\r\n        headerMenu.classList.toggle('_active');\r\n    })\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! выпадающее меню\r\n\r\ntry {\r\n    const mQuery = window.matchMedia('(max-width: 818px)');\r\n\r\n    if (mQuery.matches) {\r\n        const nth2 = document.querySelector('.menu__item:nth-child(2)');\r\n        nth2.addEventListener('click', () => {\r\n            nth2.lastElementChild.classList.toggle('_active');\r\n        })\r\n    }\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! слайдер\r\n\r\n// try {\r\n//     const mainCarousel = document.querySelectorAll('.main__carousel>*');\r\n//     window.onload = () => {\r\n//         setTimeout(() => {\r\n//             mainCarousel.forEach((value, index) => {\r\n//                 if (index === 1) {\r\n//                     const parent = value.parentElement.prepend(value);\r\n//                     value.classList.add('_active')\r\n//                 } else {\r\n//                     value.classList.remove('_active')\r\n//                 }\r\n//             })\r\n//         }, 1000)\r\n\r\n//     }\r\n\r\n// } catch (error) {\r\n\r\n// }\r\n\r\n\r\n\r\n// document.addEventListener('DOMContentLoaded', () => {\r\n//     // инициализация слайдера\r\n//     new ItcSimpleSlider('.itcss', {\r\n//         loop: true,\r\n//         autoplay: true,\r\n//         interval: 5000,\r\n//         swipe: true,\r\n//     });\r\n// });\r\n\r\n//! Галерея\r\n\r\ntry {\r\n    const gallery = document.querySelector('.gallery__grid');\r\n    if (gallery.style.transform) {\r\n        gallery.style.transform = '';\r\n\r\n    } else {\r\n        gallery.style.transform = 'translateX(-200px)';\r\n        setInterval(() => {\r\n            gallery.style.transform = '';\r\n        }, 8000)\r\n    }\r\n\r\n\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n\r\n//! кнопка возврата на главной\r\n\r\ntry {\r\n    const detailsButton = document.querySelector('.details__button');\r\n    const vozvratOverlay = document.querySelector('.vozvrat__overlay');\r\n\r\n    detailsButton.addEventListener('click', () => {\r\n        window.vozvrat.style.display = 'block';\r\n    })\r\n\r\n    vozvratOverlay.addEventListener('click', (e) => {\r\n        if (!e.target.classList.contains('vozvrat__overlay')) {\r\n            return false;\r\n        }\r\n        window.vozvrat.style.display = 'none';\r\n\r\n    })\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! input range\r\n\r\ntry {\r\n    window.onload = () => {\r\n        const formsTtle = document.querySelector('.forms__title span');\r\n        const inputTypeRange = document.querySelector('input[type=\"range\"]');\r\n\r\n        inputTypeRange.addEventListener('change', (e) => {\r\n            let value = e.target.value;\r\n            formsTtle.textContent = '(' + value + ' руб)';\r\n        })\r\n    }\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! фильтры \r\n\r\ntry {\r\n    const filters = document.querySelector('.filters');\r\n    const forms = document.querySelector('.forms');\r\n    const formsClose = document.querySelector('.forms__close');\r\n    const body = document.querySelector('body');\r\n\r\n\r\n    filters.addEventListener('click', () => {\r\n        forms.classList.add('_active');\r\n        formsClose.classList.add('_active');\r\n        body.classList.add('_active');\r\n    })\r\n    formsClose.addEventListener('click', () => {\r\n        forms.classList.remove('_active');\r\n        formsClose.classList.remove('_active');\r\n        body.classList.remove('_active');\r\n\r\n    })\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! галареия на single\r\n\r\ntry {\r\n\r\n    const kartinkiBig = document.querySelector('.kartinki__big');\r\n    const kartinkiSmall = document.querySelectorAll('.kartinki__small');\r\n\r\n    window.onload = () => {\r\n        kartinkiBig && (kartinkiBig.firstElementChild.src = kartinkiSmall[0].firstElementChild.src);\r\n    };\r\n\r\n    kartinkiSmall.forEach(value => value.addEventListener('click', () => {\r\n        const src = value.firstElementChild.src;\r\n        kartinkiBig.firstElementChild.src = src;\r\n    }))\r\n\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! ВРЕМЕННОЕ РЕШЕНИЕ ДЛЯ КНОПКИ КУПИТЬ\r\n\r\ntry {\r\n    const positionButton = document.querySelectorAll('.position__button');\r\n    positionButton.forEach(value => value.addEventListener('click', () => {\r\n        window.location.replace('single.html');\r\n    }))\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! ВРЕМЕННОЕ РЕШЕНИЕ ДЛЯ ГАЛЕРЕИ\r\n\r\ntry {\r\n    const galleryItem = document.querySelectorAll('.gallery__item');\r\n    galleryItem.forEach(value => value.innerHTML = `<img src=\"./img/aaa.jpg\" alt=\"\">`)\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! обзервер\r\n\r\ntry {\r\n\r\n    const positions = document.querySelectorAll('.position');\r\n    const cardsItems = document.querySelectorAll('.cards__item');\r\n    const katalogElement = document.querySelectorAll('.katalog__element');\r\n\r\n    var observer = new IntersectionObserver((entries) => {\r\n        entries.forEach(value => {\r\n            (value.isIntersecting) && (value.target.style.opacity = '1');\r\n        })\r\n    });\r\n\r\n    positions && positions.forEach(value => observer.observe(value));\r\n    cardsItems && cardsItems.forEach(value => observer.observe(value));\r\n    katalogElement && katalogElement.forEach(value => observer.observe(value));\r\n} catch (error) {\r\n\r\n}\r\n\r\n\n\n//# sourceURL=webpack://gulp2022/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/simple-adaptive-slider.js":
/*!**************************************************!*\
  !*** ./src/js/modules/simple-adaptive-slider.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ItcSimpleSlider: () => (/* binding */ ItcSimpleSlider)\n/* harmony export */ });\n/* eslint-disable no-param-reassign,getter-return */\n// noinspection DuplicatedCode\n\n/**\n * SimpleAdaptiveSlider by itchief (https://github.com/itchief/ui-components/tree/master/simple-adaptive-slider)\n * Copyright 2020 - 2023 Alexander Maltsev\n * Licensed under MIT (https://github.com/itchief/ui-components/blob/master/LICENSE)\n */\n\nclass ItcSimpleSlider {\n  // базовые классы и селекторы\n  static PREFIX = 'itcss';\n  static EL_WRAPPER = `${ItcSimpleSlider.PREFIX}__wrapper`;\n  static EL_ITEM = `${ItcSimpleSlider.PREFIX}__item`;\n  static EL_ITEM_ACTIVE = `${ItcSimpleSlider.PREFIX}__item_active`;\n  static EL_ITEMS = `${ItcSimpleSlider.PREFIX}__items`;\n  static EL_INDICATOR = `${ItcSimpleSlider.PREFIX}__indicator`;\n  static EL_INDICATOR_ACTIVE = `${ItcSimpleSlider.PREFIX}__indicator_active`;\n  static EL_INDICATORS = `${ItcSimpleSlider.PREFIX}__indicators`;\n  static EL_CONTROL = `${ItcSimpleSlider.PREFIX}__btn`;\n  // порог для переключения слайда (20%)\n  static SWIPE_THRESHOLD = 20;\n  // класс для отключения transition\n  static TRANSITION_NONE = 'transition-none';\n  // Определите, поддерживает ли текущий клиент пассивные события\n  static checkSupportPassiveEvents() {\n    let passiveSupported = false;\n    try {\n      const options = Object.defineProperty({}, 'passive', {\n        get() {\n          passiveSupported = true;\n        },\n      });\n      window.addEventListener('testPassiveListener', null, options);\n      window.removeEventListener('testPassiveListener', null, options);\n    } catch (error) {\n      passiveSupported = false;\n    }\n    return passiveSupported;\n  }\n\n  constructor(target, config) {\n    this._el = typeof target === 'string' ? document.querySelector(target) : target;\n    this._elWrapper = this._el.querySelector(`.${this.constructor.EL_WRAPPER}`);\n    this._elItems = this._el.querySelector(`.${this.constructor.EL_ITEMS}`);\n    this._elListItem = this._el.querySelectorAll(`.${this.constructor.EL_ITEM}`);\n\n    // экстремальные значения слайдов\n    this._exOrderMin = 0;\n    this._exOrderMax = 0;\n    this._exItemMin = null;\n    this._exItemMax = null;\n    this._exTranslateMin = 0;\n    this._exTranslateMax = 0;\n\n    this._states = [];\n\n    this._isBalancing = false;\n\n    // направление смены слайдов (по умолчанию)\n    this._direction = 'next';\n    // текущее значение трансформации\n    this._transform = 0;\n\n    this._clientRect = this._elWrapper.getBoundingClientRect();\n\n    this._supportResizeObserver = typeof window.ResizeObserver !== 'undefined';\n\n    const styleElItems = window.getComputedStyle(this._elItems);\n    this._delay = Math.round(parseFloat(styleElItems.transitionDuration) * 50);\n\n    // swipe параметры\n    this._hasSwipeState = false;\n    this._swipeStartPosX = 0;\n    // id таймера\n    this._intervalId = null;\n    this._config = {\n      loop: true,\n      autoplay: false,\n      interval: 5000,\n      indicators: true,\n      swipe: true,\n      ...config\n    };\n    this._elItems.dataset.translate = '0';\n    // добавляем к слайдам data-атрибуты\n    this._elListItem.forEach((item, index) => {\n      item.dataset.order = `${index}`;\n      item.dataset.index = `${index}`;\n      item.dataset.translate = '0';\n      this._states.push(index === 0 ? 1 : 0);\n    });\n\n    // перемещаем последний слайд перед первым\n    if (this._config.loop) {\n      const count = this._elListItem.length - 1;\n      const translate = -this._elListItem.length;\n      this._elListItem[count].dataset.order = '-1';\n      this._elListItem[count].dataset.translate = `${-this._elListItem.length}`;\n      const valueX = translate * this._clientRect.width;\n      this._elListItem[count].style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n    }\n    // добавляем индикаторы к слайдеру\n    this._addIndicators();\n    this._elListIndicator = this._el.querySelectorAll(`.${this.constructor.EL_INDICATOR}`);\n    // обновляем экстремальные значения переменных\n    this._updateExProperties();\n    // помечаем активные элементы\n    this._changeActiveItems();\n\n    this._config.onInit ? this._config.onInit(this) : null;\n\n    // назначаем обработчики\n    this._addEventListener();\n    // запускаем автоматическую смену слайдов\n    this._autoplay();\n  }\n\n  _changeActiveItems() {\n    this._states.forEach((item, index) => {\n      if (item) {\n        this._elListItem[index].classList.add(this.constructor.EL_ITEM_ACTIVE);\n      } else {\n        this._elListItem[index].classList.remove(this.constructor.EL_ITEM_ACTIVE);\n      }\n      if (this._elListIndicator.length && item) {\n        this._elListIndicator[index].classList.add(this.constructor.EL_INDICATOR_ACTIVE);\n      } else if (this._elListIndicator.length && !item) {\n        this._elListIndicator[index].classList.remove(this.constructor.EL_INDICATOR_ACTIVE);\n      }\n    });\n    if (this._states.length) {\n      const btnPrev = this._el.querySelector('.itcss__btn_prev');\n      const btnNext = this._el.querySelector('.itcss__btn_next');\n      if (btnPrev) {\n        this._states[0] === 1 ? btnPrev.classList.add('d-none') : btnPrev.classList.remove('d-none');\n      }\n      if (btnNext) {\n        this._states[this._states.length - 1] === 1 ? btnNext.classList.add('d-none') : btnNext.classList.remove('d-none');\n      }\n    }\n    this._el.dispatchEvent(new CustomEvent('change.itc.slider', { bubbles: true }));\n  }\n\n  // смена слайдов\n  _move() {\n    this._elItems.classList.remove(this.constructor.TRANSITION_NONE);\n    if (this._direction === 'none') {\n      const valueX = this._transform * this._clientRect.width;\n      this._elItems.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n      return;\n    }\n    if (!this._config.loop) {\n      const isNotMovePrev = this._states[0] && this._direction === 'prev';\n      const isNotMoveNext = this._states[this._states.length - 1] && this._direction === 'next';\n      if (isNotMovePrev || isNotMoveNext) {\n        this._autoplay('stop');\n        return;\n      }\n    }\n    this._transform += this._direction === 'next' ? -1 : 1;\n    if (this._direction === 'next') {\n      this._states = [...this._states.slice(-1), ...this._states.slice(0, -1)];\n    } else if (this._direction === 'prev') {\n      this._states = [...this._states.slice(1), ...this._states.slice(0, 1)];\n    }\n    this._elItems.dataset.translate = this._transform;\n    const valueX = this._transform * this._clientRect.width;\n    this._elItems.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n    this._elItems.dispatchEvent(new CustomEvent('moving.itc.slider', { bubbles: true }));\n    this._changeActiveItems();\n    if (!this._isBalancing) {\n      this._isBalancing = true;\n      window.requestAnimationFrame(this._balanceItems.bind(this));\n    }\n  }\n\n  // функция для перемещения к слайду по индексу\n  _moveTo(index) {\n    const currIndex = this._states.indexOf(1);\n    this._direction = index > currIndex ? 'next' : 'prev';\n    for (let i = 0; i < Math.abs(index - currIndex); i++) {\n      this._move();\n    }\n  }\n\n  // метод для автоматической смены слайдов\n  _autoplay(action) {\n    if (!this._config.autoplay) {\n      return;\n    }\n    if (action === 'stop') {\n      clearInterval(this._intervalId);\n      this._intervalId = null;\n      return;\n    }\n    if (this._intervalId === null) {\n      this._intervalId = setInterval(() => {\n        this._direction = 'next';\n        this._move();\n      }, this._config.interval);\n    }\n  }\n\n  // добавление индикаторов\n  _addIndicators() {\n    const el = this._el.querySelector(`.${this.constructor.EL_INDICATORS}`);\n    if (el || !this._config.indicators) {\n      return;\n    }\n    let rows = '';\n    for (let i = 0, { length } = this._elListItem; i < length; i++) {\n      rows += `<li class=\"${this.constructor.EL_INDICATOR}\" data-slide-to=\"${i}\"></li>`;\n    }\n    const html = `<ol class=\"${this.constructor.EL_INDICATORS}\">${rows}</ol>`;\n    this._el.insertAdjacentHTML('beforeend', html);\n  }\n\n  // refresh extreme values\n  _updateExProperties() {\n    const els = Object.values(this._elListItem).map((el) => el);\n    const orders = els.map((item) => Number(item.dataset.order));\n    this._exOrderMin = Math.min(...orders);\n    this._exOrderMax = Math.max(...orders);\n    const min = orders.indexOf(this._exOrderMin);\n    const max = orders.indexOf(this._exOrderMax);\n    this._exItemMin = els[min];\n    this._exItemMax = els[max];\n    this._exTranslateMin = Number(this._exItemMin.dataset.translate);\n    this._exTranslateMax = Number(this._exItemMax.dataset.translate);\n  }\n\n  _balanceItems() {\n    if (!this._isBalancing) {\n      return;\n    }\n    if (this._direction === 'next') {\n      const exItemRight = this._exItemMin.getBoundingClientRect().right;\n      if (exItemRight < this._clientRect.left - this._clientRect.width / 2) {\n        this._exItemMin.dataset.order = `${this._exOrderMin + this._elListItem.length}`;\n        this._exItemMin.dataset.translate = `${this._exTranslateMin + this._elListItem.length}`;\n        const valueX = (this._exTranslateMin + this._elListItem.length) * this._clientRect.width;\n        this._exItemMin.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n        this._updateExProperties();\n      }\n    } else {\n      const exItemLeft = this._exItemMax.getBoundingClientRect().left;\n      if (exItemLeft > this._clientRect.right + this._clientRect.width / 2) {\n        this._exItemMax.dataset.order = `${this._exOrderMax - this._elListItem.length}`;\n        this._exItemMax.dataset.translate = `${this._exTranslateMax - this._elListItem.length}`;\n        const valueX = (this._exTranslateMax - this._elListItem.length) * this._clientRect.width;\n        this._exItemMax.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n        this._updateExProperties();\n      }\n    }\n    window.setTimeout(() => {\n      window.requestAnimationFrame(this._balanceItems.bind(this));\n    }, this._delay);\n  }\n\n  // adding listeners\n  _addEventListener() {\n    const onSwipeStart = (e) => {\n      this._autoplay('stop');\n      if (e.target.closest(`.${this.constructor.EL_CONTROL}`)) {\n        return;\n      }\n      const event = e.type.search('touch') === 0 ? e.touches[0] : e;\n      this._swipeStartPosX = event.clientX;\n      this._swipeStartPosY = event.clientY;\n      this._hasSwipeState = true;\n      this._hasSwiping = false;\n    };\n    const onSwipeMove = (e) => {\n      if (!this._hasSwipeState) {\n        return;\n      }\n      const event = e.type.search('touch') === 0 ? e.touches[0] : e;\n      let diffPosX = this._swipeStartPosX - event.clientX;\n      const diffPosY = this._swipeStartPosY - event.clientY;\n      if (!this._hasSwiping) {\n        if (Math.abs(diffPosY) > Math.abs(diffPosX) || Math.abs(diffPosX) === 0) {\n          this._hasSwipeState = false;\n          return;\n        }\n        this._hasSwiping = true;\n      }\n      e.preventDefault();\n      if (!this._config.loop) {\n        const isNotMoveFirst = this._states[0] && diffPosX <= 0;\n        const isNotMoveLast = this._states[this._states.length - 1] && diffPosX >= 0;\n        if (isNotMoveFirst || isNotMoveLast) {\n          diffPosX /= 4;\n        }\n      }\n      this._elItems.classList.add(this.constructor.TRANSITION_NONE);\n      const valueX = this._transform * this._clientRect.width - diffPosX;\n      this._elItems.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n    };\n    const onSwipeEnd = (e) => {\n      if (!this._hasSwipeState) {\n        return;\n      }\n      const event = e.type.search('touch') === 0 ? e.changedTouches[0] : e;\n      let diffPosX = this._swipeStartPosX - event.clientX;\n      if (diffPosX === 0) {\n        this._hasSwipeState = false;\n        return;\n      }\n      if (!this._config.loop) {\n        const isNotMoveFirst = this._states[0] && diffPosX <= 0;\n        const isNotMoveLast = this._states[this._states.length - 1] && diffPosX >= 0;\n        if (isNotMoveFirst || isNotMoveLast) {\n          diffPosX = 0;\n        }\n      }\n      const value = (diffPosX / this._clientRect.width) * 100;\n      this._elItems.classList.remove(this.constructor.TRANSITION_NONE);\n      if (value > this.constructor.SWIPE_THRESHOLD) {\n        this._direction = 'next';\n        this._move();\n      } else if (value < -this.constructor.SWIPE_THRESHOLD) {\n        this._direction = 'prev';\n        this._move();\n      } else {\n        this._direction = 'none';\n        this._move();\n      }\n      this._hasSwipeState = false;\n      this._autoplay();\n    };\n    // click\n    this._el.addEventListener('click', (e) => {\n      const $target = e.target;\n      this._autoplay('stop');\n      if ($target.classList.contains(this.constructor.EL_CONTROL)) {\n        e.preventDefault();\n        this._direction = $target.dataset.slide;\n        this._move();\n      } else if ($target.dataset.slideTo) {\n        e.preventDefault();\n        const index = parseInt($target.dataset.slideTo, 10);\n        this._moveTo(index);\n      }\n      this._autoplay();\n    });\n\n    // transitionstart and transitionend\n    if (this._config.loop) {\n      this._elItems.addEventListener('transitionend', () => {\n        this._isBalancing = false;\n      });\n    }\n    // mouseenter and mouseleave\n    this._el.addEventListener('mouseenter', () => {\n      this._autoplay('stop');\n    });\n    this._el.addEventListener('mouseleave', () => {\n      this._autoplay();\n    });\n    // swipe\n    if (this._config.swipe) {\n      const options = this.constructor.checkSupportPassiveEvents() ? { passive: false } : false;\n      this._el.addEventListener('touchstart', onSwipeStart, options);\n      this._el.addEventListener('touchmove', onSwipeMove, options);\n      this._el.addEventListener('mousedown', onSwipeStart);\n      this._el.addEventListener('mousemove', onSwipeMove);\n      document.addEventListener('touchend', onSwipeEnd);\n      document.addEventListener('mouseup', onSwipeEnd);\n      document.addEventListener('mouseout', onSwipeEnd);\n    }\n    this._el.addEventListener('dragstart', (e) => {\n      e.preventDefault();\n    });\n    // при изменении активности вкладки\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'visible' && this._config.loop) {\n        this._autoplay();\n      } else {\n        this._autoplay('stop');\n      }\n    });\n    if (this._supportResizeObserver) {\n      const resizeObserver = new ResizeObserver((entries) => {\n        const { contentRect } = entries[0];\n        if (Math.round(this._clientRect.width * 10) === Math.round(contentRect.width * 10)) {\n          return;\n        }\n        this._clientRect = contentRect;\n        const newValueX = contentRect.width * Number(this._elItems.dataset.translate);\n        this.reset(newValueX, true);\n        this._autoplay();\n      });\n      resizeObserver.observe(this._elWrapper);\n    }\n  }\n\n  reset(newValueX = 0, recalc = false) {\n    this._autoplay('stop');\n    this._elItems.classList.add(this.constructor.TRANSITION_NONE);\n    this._elItems.style.transform = `translate3D(${newValueX}px, 0px, 0.1px)`;\n    this._elListItem.forEach((el) => {\n      const valueX = recalc ? Number(el.dataset.translate) * this._clientRect.width : 0;\n      el.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n    });\n    if (!recalc) {\n      this._transform = 0;\n      this._states = [];\n      this._elItems.dataset.translate = '0';\n      this._elListItem = this._el.querySelectorAll(`.${this.constructor.EL_ITEM}`);\n      // добавляем к слайдам data-атрибуты\n      this._elListItem.forEach((item, index) => {\n        item.dataset.order = `${index}`;\n        item.dataset.index = `${index}`;\n        item.dataset.translate = '0';\n        this._states.push(index === 0 ? 1 : 0);\n      });\n      // перемещаем последний слайд перед первым\n      if (this._config.loop) {\n        const count = this._elListItem.length - 1;\n        const translate = -this._elListItem.length;\n        this._elListItem[count].dataset.order = '-1';\n        this._elListItem[count].dataset.translate = `${-this._elListItem.length}`;\n        const valueX = translate * this._clientRect.width;\n        this._elListItem[count].style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\n      }\n      this._el.querySelector(`.${this.constructor.EL_INDICATORS}`).remove();\n      // добавляем индикаторы к слайдеру\n      this._addIndicators();\n      this._elListIndicator = document.querySelectorAll(`.${this.constructor.EL_INDICATOR}`);\n      // обновляем экстремальные значения переменных\n      this._updateExProperties();\n      // помечаем активные элементы\n      this._changeActiveItems();\n    }\n    this._autoplay();\n  }\n\n  // перейти к следующему слайду\n  next() {\n    this._direction = 'next';\n    this._move();\n  }\n  // перейти к предыдущему слайду\n  prev() {\n    this._direction = 'prev';\n    this._move();\n  }\n  // управление автоматической сменой слайдов\n  autoplay() {\n    this._autoplay('stop');\n  }\n  moveTo(index) {\n    this._moveTo(index);\n  }\n}\n\n\n//# sourceURL=webpack://gulp2022/./src/js/modules/simple-adaptive-slider.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;