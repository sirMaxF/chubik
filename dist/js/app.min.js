/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/app.js":
/*!***********************!*\
  !*** ./src/js/app.js ***!
  \***********************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_simple_adaptive_slider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/simple-adaptive-slider.js */ \"./src/js/modules/simple-adaptive-slider.js\");\n\r\n\r\n// flsFunctions.isWebp();\r\n\r\n\r\n// слайдер\r\n\r\n// import Swiper, { Navigation, Pagination } from 'swiper';\r\n\r\n// Swiper.use([Navigation, Pagination]);\r\n// или же можем подключить и активировать сразу все модули. Но они весят очень много!!!\r\n// import Swiper from 'swiper/bundle';\r\n// Swiper.use();\r\n\r\n// const swiper = new Swiper('.swiper', {\r\n\r\n//     navigation: {\r\n//         nextEl: '.swiper-button-next',\r\n//         prevEl: '.swiper-button-prev'\r\n//     },\r\n\r\n//     slidesPerView: 2,\r\n// });\r\n\r\n\r\n\r\n//! адаптивное меню\r\n\r\ntry {\r\n    const menuIcon = document.querySelector('.menu__icon');\r\n    const headerMenu = document.querySelector('.menu__row');\r\n\r\n    menuIcon.addEventListener('click', () => {\r\n        headerMenu.classList.toggle('_active');\r\n    })\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! выпадающее меню\r\n\r\ntry {\r\n    const mQuery = window.matchMedia('(max-width: 818px)');\r\n\r\n    if (mQuery.matches) {\r\n        const nth2 = document.querySelector('.menu__item:nth-child(2)');\r\n        nth2.addEventListener('click', () => {\r\n            nth2.lastElementChild.classList.toggle('_active');\r\n        })\r\n    }\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! слайдер\r\n\r\n// try {\r\n//     const mainCarousel = document.querySelectorAll('.main__carousel>*');\r\n//     window.onload = () => {\r\n//         setTimeout(() => {\r\n//             mainCarousel.forEach((value, index) => {\r\n//                 if (index === 1) {\r\n//                     const parent = value.parentElement.prepend(value);\r\n//                     value.classList.add('_active')\r\n//                 } else {\r\n//                     value.classList.remove('_active')\r\n//                 }\r\n//             })\r\n//         }, 1000)\r\n\r\n//     }\r\n\r\n// } catch (error) {\r\n\r\n// }\r\n\r\n\r\n\r\n// document.addEventListener('DOMContentLoaded', () => {\r\n//     // инициализация слайдера\r\n//     new ItcSimpleSlider('.itcss', {\r\n//         loop: true,\r\n//         autoplay: true,\r\n//         interval: 5000,\r\n//         swipe: true,\r\n//     });\r\n// });\r\n\r\n//! Галерея\r\n\r\ntry {\r\n    const gallery = document.querySelector('.gallery__grid');\r\n    if (gallery.style.transform) {\r\n        gallery.style.transform = '';\r\n\r\n    } else {\r\n        gallery.style.transform = 'translateX(-200px)';\r\n        setInterval(() => {\r\n            gallery.style.transform = '';\r\n        }, 8000)\r\n    }\r\n\r\n\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n\r\n//! кнопка возврата на главной\r\n\r\ntry {\r\n    const detailsButton = document.querySelector('.details__button')\r\n    const vozvratOverlay = document.querySelector('.vozvrat__overlay');\r\n    const vozvratContaine = document.querySelector('.vozvrat__container')\r\n    detailsButton.addEventListener('click', () => {\r\n        window.vozvrat.style.display = 'block';\r\n    })\r\n\r\n    vozvratOverlay.addEventListener('click', (e) => {\r\n        alert('ff')\r\n        if (!e.target.classList.contains('vozvrat__overlay')) {\r\n            return false;\r\n        }\r\n        window.vozvrat.style.display = 'none';\r\n\r\n    })\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! input range\r\n\r\ntry {\r\n    // window.onload = () => {\r\n    const formsTtle = document.querySelector('.forms__title span');\r\n    const inputTypeRange = document.querySelector('input[type=\"range\"]');\r\n\r\n    inputTypeRange.addEventListener('change', (e) => {\r\n        let value = e.target.value;\r\n        formsTtle.textContent = '(' + value + ' руб)';\r\n    })\r\n    // }\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! фильтры \r\n\r\ntry {\r\n    const filters = document.querySelector('.filters');\r\n    const forms = document.querySelector('.forms');\r\n    const formsClose = document.querySelector('.forms__close');\r\n    const body = document.querySelector('body');\r\n\r\n\r\n    filters.addEventListener('click', () => {\r\n        forms.classList.add('_active');\r\n        formsClose.classList.add('_active');\r\n        body.classList.add('_active');\r\n    })\r\n    formsClose.addEventListener('click', () => {\r\n        forms.classList.remove('_active');\r\n        formsClose.classList.remove('_active');\r\n        body.classList.remove('_active');\r\n\r\n    })\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! галареия на single\r\n\r\ntry {\r\n\r\n    // window.onload = () => {\r\n\r\n    const kartinkiBig = document.querySelector('.kartinki__big');\r\n    const kartinkiSmall = document.querySelectorAll('.kartinki__small');\r\n\r\n    window.onload = () => {\r\n        kartinkiBig && (kartinkiBig.firstElementChild.src = kartinkiSmall[0].firstElementChild.src);\r\n    };\r\n\r\n    // kartinkiSmall.forEach(value => value.addEventListener('click', () => {\r\n    //     const src = value.firstElementChild.src;\r\n    //     kartinkiBig.firstElementChild.src = src;\r\n    //     window.BlowupLens.style.backgroundImage = `url(${src})`;\r\n    // }))\r\n    // }\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! ВРЕМЕННОЕ РЕШЕНИЕ ДЛЯ КНОПКИ КУПИТЬ\r\n\r\ntry {\r\n    const positionButton = document.querySelectorAll('.position');\r\n    positionButton.forEach(value => value.addEventListener('click', () => {\r\n        window.location.assign('single.html');\r\n    }))\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! ВРЕМЕННОЕ РЕШЕНИЕ ДЛЯ СПИСКА ТОВАРОВ\r\n\r\ntry {\r\n    const inputNameOdzhd = document.querySelectorAll('input[name=\"odzhd\"]');\r\n    const selectPositions = document.querySelector('.select__positions');\r\n\r\n    function render(arr, renderFlag = false) {\r\n        selectPositions.innerHTML = '';\r\n\r\n        arr.forEach(value => {\r\n            selectPositions.insertAdjacentHTML('afterbegin', `\r\n                        <div class=\"position\" ${renderFlag && 'style=\"opacity: 1\"'} onclick=\"window.location.assign('single.html')\">\r\n                            <div class=\"position__image\"><img src=\"${value.img}\" alt=\"\"></div>\r\n                            <div class=\"position__title\">${value.name}</div>\r\n                            <div class=\"position__price\">2100 руб</div>\r\n                            <div class=\"position__button\">Выбрать размер</div>\r\n                        </div>\r\n                    `)\r\n        })\r\n    }\r\n\r\n    let result;\r\n\r\n    if (inputNameOdzhd) {\r\n        const response = await fetch('https://667c1b9d3c30891b865b56aa.mockapi.io/photos/images');\r\n        result = await response.json();\r\n\r\n        render(result);\r\n\r\n        // result.forEach(value => {\r\n        //     selectPositions.insertAdjacentHTML('afterbegin', `\r\n        //                 <div class=\"position\">\r\n        //                     <div class=\"position__image\"><img src=\"${value.img}\" alt=\"\"></div>\r\n        //                     <div class=\"position__title\">${value.name}</div>\r\n        //                     <div class=\"position__price\">2100 руб</div>\r\n        //                     <div class=\"position__button\">Выбрать размер</div>\r\n        //                 </div>\r\n        //             `)\r\n        // })\r\n    };\r\n    console.log(result)\r\n\r\n\r\n    inputNameOdzhd.forEach(value => value.addEventListener('change', (e) => {\r\n        selectPositions.innerHTML = '';\r\n        const inputVal = e.target.value;\r\n\r\n        inputNameOdzhd.forEach((item) => {\r\n            if (item !== e.target) item.checked = false\r\n        })\r\n\r\n        switch (inputVal) {\r\n            case 'yes1':\r\n                const yes1 = result.filter(value => value.category === '1');\r\n                render(yes1, true);\r\n                break;\r\n            case 'yes2':\r\n                const yes2 = result.filter(value => (value.category === '2'));\r\n                render(yes2, true);\r\n                break;\r\n            case 'yes3':\r\n                const yes3 = result.filter(value => value.category === '9');\r\n                render(yes3, true);\r\n                break;\r\n            case 'yes4':\r\n                const yes4 = result.filter(value => value.category === '4');\r\n                render(yes4, true);\r\n                break;\r\n            // default:\r\n            //     break;\r\n\r\n        }\r\n\r\n        let isChecked = Array.from(inputNameOdzhd).some(checkbox => checkbox.checked);\r\n\r\n        if (!isChecked) {\r\n            render(result, true);\r\n        }\r\n\r\n\r\n\r\n        console.log(inputVal);\r\n    }))\r\n\r\n} catch (error) {\r\n    console.log(error)\r\n}\r\n\r\n//! ВРЕМЕННОЕ РЕШЕНИЕ ДЛЯ ГАЛЕРЕИ\r\n\r\ntry {\r\n    const galleryItem = document.querySelectorAll('.gallery__item');\r\n    galleryItem.forEach(value => value.innerHTML = `<img src=\"./img/aaa.jpg\" alt=\"\">`)\r\n\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! обзервер\r\n\r\ntry {\r\n\r\n    const positions = document.querySelectorAll('.position');\r\n    const cardsItems = document.querySelectorAll('.cards__item');\r\n    const katalogElement = document.querySelectorAll('.katalog__element');\r\n\r\n    var observer = new IntersectionObserver((entries) => {\r\n        entries.forEach(value => {\r\n            (value.isIntersecting) && (value.target.style.opacity = '1');\r\n        })\r\n    });\r\n\r\n    positions && positions.forEach(value => observer.observe(value));\r\n    cardsItems && cardsItems.forEach(value => observer.observe(value));\r\n    katalogElement && katalogElement.forEach(value => observer.observe(value));\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! кнопка назад\r\n\r\ntry {\r\n    const singleReturn = document.querySelector('.single__return');\r\n    singleReturn.addEventListener('click', () => {\r\n        window.history.back();\r\n    })\r\n} catch (error) {\r\n\r\n}\r\n\r\n//! большая картинка\r\n\r\n// try {\r\n//     const kartinkiBig = document.querySelector('.kartinki__big img');\r\n\r\n\r\n//     // kartinkiBig.addEventListener('mousemove', (e) => {\r\n//     //     const y = e.clientY / 2;\r\n//     //     const x = e.clientX / 2;\r\n//     //     // const y = e.offsetTop / 1;\r\n//     //     // const x = e.offsetLeft / 1;\r\n//     //     console.log(x)\r\n//     //     kartinkiBig.style.transform = `translate(-${x}px, -${y}px) scale(3)`;\r\n//     // });\r\n\r\n//     let counter = true;\r\n//     kartinkiBig.addEventListener('click', () => {\r\n//         counter = !counter;\r\n//         if (!counter) {\r\n//             kartinkiBig.classList.toggle('_active')\r\n\r\n//             kartinkiBig.addEventListener('mousemove', (e) => {\r\n//                 const y = e.clientY / 3;\r\n//                 const x = e.clientX / 3;\r\n//                 kartinkiBig.style.transform = `translate(-${x}px, -${y}px)`;\r\n//             })\r\n//         } else {\r\n//             // counter = !counter;\r\n//             kartinkiBig.classList.toggle('_active')\r\n//             kartinkiBig.addEventListener('mousemove', (e) => {\r\n//                 return false;\r\n//             })\r\n//             kartinkiBig.style.transform = `translate(0px, 0px)`;\r\n\r\n//         }\r\n\r\n//     })\r\n\r\n\r\n\r\n//     kartinkiBig.addEventListener('mouseout', () => {\r\n//         kartinkiBig.style.transform = `translate(0px, 0px)`;\r\n//     })\r\n\r\n// } catch (error) {\r\n\r\n// }\r\n\r\n//! лупа\r\n\r\n// $(document).ready(function () {\r\n//     $(\".kartinki__big img\").blowup();\r\n// })\r\n\r\n//! лупа 2\r\n\r\n// try {\r\n//     let zoom = document.querySelectorAll('.image-zoom');\r\n\r\n//     zoom.forEach(function (el) {\r\n//         el.addEventListener('click', function (e) {\r\n//             const target = e.target.closest('.image-zoom'),\r\n//                 rect = target.getBoundingClientRect();\r\n//             target.classList.toggle('-active');\r\n//             target.style.setProperty('--image', `url(${target.querySelector('img').getAttribute('src')})`);\r\n//             target.style.setProperty('--x', Math.floor(((e.clientX - rect.left) / rect.width * 100) * 100) / 100 + '%');\r\n//             target.style.setProperty('--y', Math.floor(((e.clientY - rect.top) / rect.height * 100) * 100) / 100 + '%');\r\n//             target.classList.toggle('-enter');\r\n//         });\r\n\r\n//         el.addEventListener('mouseenter', function (e) {\r\n//             const target = e.target.closest('.image-zoom');\r\n//             if (target.classList.contains('-active')) {\r\n//                 target.classList.add('-enter');\r\n//             }\r\n//         });\r\n\r\n//         el.addEventListener('mousemove', function (e) {\r\n//             const target = e.target.closest('.image-zoom');\r\n//             if (target.classList.contains('-active')) {\r\n//                 const rect = target.getBoundingClientRect();\r\n//                 target.style.setProperty('--x', Math.floor(((e.clientX - rect.left) / rect.width * 100) * 100) / 100 + '%');\r\n//                 target.style.setProperty('--y', Math.floor(((e.clientY - rect.top) / rect.height * 100) * 100) / 100 + '%');\r\n//             }\r\n//         });\r\n\r\n//         el.addEventListener('mouseleave', function (e) {\r\n//             let target = e.target.closest('.image-zoom');\r\n//             if (target.classList.contains('-active')) {\r\n//                 target.classList.remove('-enter');\r\n//             }\r\n//         });\r\n//     });\r\n// } catch (error) {\r\n\r\n// }\r\n\r\n//! переключение галереи\r\n\r\ntry {\r\n    const kartinkiBig = document.querySelector('.kartinki__big');\r\n    const popnewOverlay = document.querySelector('.popnew__overlay');\r\n    const popnewContainer = document.querySelector('.popnew__container')\r\n    const vozvratNew = document.querySelector('.vozvrat_new');\r\n\r\n    const kartinkiSmall = document.querySelectorAll('.kartinki__small');\r\n    let count = 0;\r\n\r\n    // window.onload = () => {\r\n    if (kartinkiBig) {\r\n        kartinkiBig.addEventListener('click', (e) => {\r\n            if (e.target.parentElement.classList.contains('kartinki__prkl')) {\r\n\r\n                if (e.target.parentElement.classList.contains('kartinki__prkl_right')) {\r\n                    ++count;\r\n                    console.log(count)\r\n                    if (count >= (kartinkiSmall.length - 1)) {\r\n                        document.querySelector('.kartinki__prkl_right').style.display = 'none';\r\n                        kartinkiBig.firstElementChild.src = kartinkiSmall[count].firstElementChild.src;\r\n                    } else {\r\n                        kartinkiBig.firstElementChild.src = kartinkiSmall[count].firstElementChild.src;\r\n                    }\r\n                    document.querySelector('.kartinki__prkl_left').style.display = 'block';\r\n\r\n                }\r\n\r\n                if (e.target.parentElement.classList.contains('kartinki__prkl_left')) {\r\n                    --count;\r\n                    if (count <= 0) {\r\n                        document.querySelector('.kartinki__prkl_left').style.display = 'none';\r\n                        kartinkiBig.firstElementChild.src = kartinkiSmall[count].firstElementChild.src;\r\n                    } else {\r\n                        kartinkiBig.firstElementChild.src = kartinkiSmall[count].firstElementChild.src;\r\n                    }\r\n                    document.querySelector('.kartinki__prkl_right').style.display = 'block';\r\n\r\n                }\r\n\r\n                return false;\r\n            }\r\n\r\n\r\n            popnewContainer.style.backgroundImage = `url(${kartinkiBig.firstElementChild.src})`;\r\n            // vozvratNew.classList.add('_active')\r\n            window.popnew.style.display = 'block';\r\n        })\r\n\r\n\r\n    }\r\n    // }\r\n\r\n    popnewOverlay.addEventListener('click', (el) => {\r\n        if (!el.target.classList.contains('popnew__overlay')) {\r\n            return false;\r\n        }\r\n        window.popnew.style.display = 'none';\r\n        // vozvratNew.classList.remove('_active')\r\n\r\n    })\r\n\r\n} catch (error) {\r\n    console.log(error)\r\n}\r\n\r\n//! свайпы\r\n\r\ntry {\r\n\r\n\r\n    // var square = document.querySelector('.square');\r\n    // var manager = new Hammer.Manager(square);\r\n    // var Swipe = new Hammer.Swipe();\r\n    // manager.add(Swipe);\r\n    // manager.on('swipe', function (e) {\r\n    //     var direction = e.offsetDirection;\r\n    //     if (direction === 2) {\r\n    //         detailsButton.firstElementChild.src = kartinkiSmall[1].firstElementChild.src;\r\n\r\n    //     }\r\n    // });\r\n} catch (error) {\r\n\r\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://gulp2022/./src/js/app.js?");

/***/ }),

/***/ "./src/js/modules/simple-adaptive-slider.js":
/*!**************************************************!*\
  !*** ./src/js/modules/simple-adaptive-slider.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ItcSimpleSlider: () => (/* binding */ ItcSimpleSlider)\n/* harmony export */ });\n/* eslint-disable no-param-reassign,getter-return */\r\n// noinspection DuplicatedCode\r\n\r\n/**\r\n * SimpleAdaptiveSlider by itchief (https://github.com/itchief/ui-components/tree/master/simple-adaptive-slider)\r\n * Copyright 2020 - 2023 Alexander Maltsev\r\n * Licensed under MIT (https://github.com/itchief/ui-components/blob/master/LICENSE)\r\n */\r\n\r\nclass ItcSimpleSlider {\r\n  // базовые классы и селекторы\r\n  static PREFIX = 'itcss';\r\n  static EL_WRAPPER = `${ItcSimpleSlider.PREFIX}__wrapper`;\r\n  static EL_ITEM = `${ItcSimpleSlider.PREFIX}__item`;\r\n  static EL_ITEM_ACTIVE = `${ItcSimpleSlider.PREFIX}__item_active`;\r\n  static EL_ITEMS = `${ItcSimpleSlider.PREFIX}__items`;\r\n  static EL_INDICATOR = `${ItcSimpleSlider.PREFIX}__indicator`;\r\n  static EL_INDICATOR_ACTIVE = `${ItcSimpleSlider.PREFIX}__indicator_active`;\r\n  static EL_INDICATORS = `${ItcSimpleSlider.PREFIX}__indicators`;\r\n  static EL_CONTROL = `${ItcSimpleSlider.PREFIX}__btn`;\r\n  // порог для переключения слайда (20%)\r\n  static SWIPE_THRESHOLD = 20;\r\n  // класс для отключения transition\r\n  static TRANSITION_NONE = 'transition-none';\r\n  // Определите, поддерживает ли текущий клиент пассивные события\r\n  static checkSupportPassiveEvents() {\r\n    let passiveSupported = false;\r\n    try {\r\n      const options = Object.defineProperty({}, 'passive', {\r\n        get() {\r\n          passiveSupported = true;\r\n        },\r\n      });\r\n      window.addEventListener('testPassiveListener', null, options);\r\n      window.removeEventListener('testPassiveListener', null, options);\r\n    } catch (error) {\r\n      passiveSupported = false;\r\n    }\r\n    return passiveSupported;\r\n  }\r\n\r\n  constructor(target, config) {\r\n    this._el = typeof target === 'string' ? document.querySelector(target) : target;\r\n    this._elWrapper = this._el.querySelector(`.${this.constructor.EL_WRAPPER}`);\r\n    this._elItems = this._el.querySelector(`.${this.constructor.EL_ITEMS}`);\r\n    this._elListItem = this._el.querySelectorAll(`.${this.constructor.EL_ITEM}`);\r\n\r\n    // экстремальные значения слайдов\r\n    this._exOrderMin = 0;\r\n    this._exOrderMax = 0;\r\n    this._exItemMin = null;\r\n    this._exItemMax = null;\r\n    this._exTranslateMin = 0;\r\n    this._exTranslateMax = 0;\r\n\r\n    this._states = [];\r\n\r\n    this._isBalancing = false;\r\n\r\n    // направление смены слайдов (по умолчанию)\r\n    this._direction = 'next';\r\n    // текущее значение трансформации\r\n    this._transform = 0;\r\n\r\n    this._clientRect = this._elWrapper.getBoundingClientRect();\r\n\r\n    this._supportResizeObserver = typeof window.ResizeObserver !== 'undefined';\r\n\r\n    const styleElItems = window.getComputedStyle(this._elItems);\r\n    this._delay = Math.round(parseFloat(styleElItems.transitionDuration) * 50);\r\n\r\n    // swipe параметры\r\n    this._hasSwipeState = false;\r\n    this._swipeStartPosX = 0;\r\n    // id таймера\r\n    this._intervalId = null;\r\n    this._config = {\r\n      loop: true,\r\n      autoplay: false,\r\n      interval: 5000,\r\n      indicators: true,\r\n      swipe: true,\r\n      ...config\r\n    };\r\n    this._elItems.dataset.translate = '0';\r\n    // добавляем к слайдам data-атрибуты\r\n    this._elListItem.forEach((item, index) => {\r\n      item.dataset.order = `${index}`;\r\n      item.dataset.index = `${index}`;\r\n      item.dataset.translate = '0';\r\n      this._states.push(index === 0 ? 1 : 0);\r\n    });\r\n\r\n    // перемещаем последний слайд перед первым\r\n    if (this._config.loop) {\r\n      const count = this._elListItem.length - 1;\r\n      const translate = -this._elListItem.length;\r\n      this._elListItem[count].dataset.order = '-1';\r\n      this._elListItem[count].dataset.translate = `${-this._elListItem.length}`;\r\n      const valueX = translate * this._clientRect.width;\r\n      this._elListItem[count].style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n    }\r\n    // добавляем индикаторы к слайдеру\r\n    this._addIndicators();\r\n    this._elListIndicator = this._el.querySelectorAll(`.${this.constructor.EL_INDICATOR}`);\r\n    // обновляем экстремальные значения переменных\r\n    this._updateExProperties();\r\n    // помечаем активные элементы\r\n    this._changeActiveItems();\r\n\r\n    this._config.onInit ? this._config.onInit(this) : null;\r\n\r\n    // назначаем обработчики\r\n    this._addEventListener();\r\n    // запускаем автоматическую смену слайдов\r\n    this._autoplay();\r\n  }\r\n\r\n  _changeActiveItems() {\r\n    this._states.forEach((item, index) => {\r\n      if (item) {\r\n        this._elListItem[index].classList.add(this.constructor.EL_ITEM_ACTIVE);\r\n      } else {\r\n        this._elListItem[index].classList.remove(this.constructor.EL_ITEM_ACTIVE);\r\n      }\r\n      if (this._elListIndicator.length && item) {\r\n        this._elListIndicator[index].classList.add(this.constructor.EL_INDICATOR_ACTIVE);\r\n      } else if (this._elListIndicator.length && !item) {\r\n        this._elListIndicator[index].classList.remove(this.constructor.EL_INDICATOR_ACTIVE);\r\n      }\r\n    });\r\n    if (this._states.length) {\r\n      const btnPrev = this._el.querySelector('.itcss__btn_prev');\r\n      const btnNext = this._el.querySelector('.itcss__btn_next');\r\n      if (btnPrev) {\r\n        this._states[0] === 1 ? btnPrev.classList.add('d-none') : btnPrev.classList.remove('d-none');\r\n      }\r\n      if (btnNext) {\r\n        this._states[this._states.length - 1] === 1 ? btnNext.classList.add('d-none') : btnNext.classList.remove('d-none');\r\n      }\r\n    }\r\n    this._el.dispatchEvent(new CustomEvent('change.itc.slider', { bubbles: true }));\r\n  }\r\n\r\n  // смена слайдов\r\n  _move() {\r\n    this._elItems.classList.remove(this.constructor.TRANSITION_NONE);\r\n    if (this._direction === 'none') {\r\n      const valueX = this._transform * this._clientRect.width;\r\n      this._elItems.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n      return;\r\n    }\r\n    if (!this._config.loop) {\r\n      const isNotMovePrev = this._states[0] && this._direction === 'prev';\r\n      const isNotMoveNext = this._states[this._states.length - 1] && this._direction === 'next';\r\n      if (isNotMovePrev || isNotMoveNext) {\r\n        this._autoplay('stop');\r\n        return;\r\n      }\r\n    }\r\n    this._transform += this._direction === 'next' ? -1 : 1;\r\n    if (this._direction === 'next') {\r\n      this._states = [...this._states.slice(-1), ...this._states.slice(0, -1)];\r\n    } else if (this._direction === 'prev') {\r\n      this._states = [...this._states.slice(1), ...this._states.slice(0, 1)];\r\n    }\r\n    this._elItems.dataset.translate = this._transform;\r\n    const valueX = this._transform * this._clientRect.width;\r\n    this._elItems.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n    this._elItems.dispatchEvent(new CustomEvent('moving.itc.slider', { bubbles: true }));\r\n    this._changeActiveItems();\r\n    if (!this._isBalancing) {\r\n      this._isBalancing = true;\r\n      window.requestAnimationFrame(this._balanceItems.bind(this));\r\n    }\r\n  }\r\n\r\n  // функция для перемещения к слайду по индексу\r\n  _moveTo(index) {\r\n    const currIndex = this._states.indexOf(1);\r\n    this._direction = index > currIndex ? 'next' : 'prev';\r\n    for (let i = 0; i < Math.abs(index - currIndex); i++) {\r\n      this._move();\r\n    }\r\n  }\r\n\r\n  // метод для автоматической смены слайдов\r\n  _autoplay(action) {\r\n    if (!this._config.autoplay) {\r\n      return;\r\n    }\r\n    if (action === 'stop') {\r\n      clearInterval(this._intervalId);\r\n      this._intervalId = null;\r\n      return;\r\n    }\r\n    if (this._intervalId === null) {\r\n      this._intervalId = setInterval(() => {\r\n        this._direction = 'next';\r\n        this._move();\r\n      }, this._config.interval);\r\n    }\r\n  }\r\n\r\n  // добавление индикаторов\r\n  _addIndicators() {\r\n    const el = this._el.querySelector(`.${this.constructor.EL_INDICATORS}`);\r\n    if (el || !this._config.indicators) {\r\n      return;\r\n    }\r\n    let rows = '';\r\n    for (let i = 0, { length } = this._elListItem; i < length; i++) {\r\n      rows += `<li class=\"${this.constructor.EL_INDICATOR}\" data-slide-to=\"${i}\"></li>`;\r\n    }\r\n    const html = `<ol class=\"${this.constructor.EL_INDICATORS}\">${rows}</ol>`;\r\n    this._el.insertAdjacentHTML('beforeend', html);\r\n  }\r\n\r\n  // refresh extreme values\r\n  _updateExProperties() {\r\n    const els = Object.values(this._elListItem).map((el) => el);\r\n    const orders = els.map((item) => Number(item.dataset.order));\r\n    this._exOrderMin = Math.min(...orders);\r\n    this._exOrderMax = Math.max(...orders);\r\n    const min = orders.indexOf(this._exOrderMin);\r\n    const max = orders.indexOf(this._exOrderMax);\r\n    this._exItemMin = els[min];\r\n    this._exItemMax = els[max];\r\n    this._exTranslateMin = Number(this._exItemMin.dataset.translate);\r\n    this._exTranslateMax = Number(this._exItemMax.dataset.translate);\r\n  }\r\n\r\n  _balanceItems() {\r\n    if (!this._isBalancing) {\r\n      return;\r\n    }\r\n    if (this._direction === 'next') {\r\n      const exItemRight = this._exItemMin.getBoundingClientRect().right;\r\n      if (exItemRight < this._clientRect.left - this._clientRect.width / 2) {\r\n        this._exItemMin.dataset.order = `${this._exOrderMin + this._elListItem.length}`;\r\n        this._exItemMin.dataset.translate = `${this._exTranslateMin + this._elListItem.length}`;\r\n        const valueX = (this._exTranslateMin + this._elListItem.length) * this._clientRect.width;\r\n        this._exItemMin.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n        this._updateExProperties();\r\n      }\r\n    } else {\r\n      const exItemLeft = this._exItemMax.getBoundingClientRect().left;\r\n      if (exItemLeft > this._clientRect.right + this._clientRect.width / 2) {\r\n        this._exItemMax.dataset.order = `${this._exOrderMax - this._elListItem.length}`;\r\n        this._exItemMax.dataset.translate = `${this._exTranslateMax - this._elListItem.length}`;\r\n        const valueX = (this._exTranslateMax - this._elListItem.length) * this._clientRect.width;\r\n        this._exItemMax.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n        this._updateExProperties();\r\n      }\r\n    }\r\n    window.setTimeout(() => {\r\n      window.requestAnimationFrame(this._balanceItems.bind(this));\r\n    }, this._delay);\r\n  }\r\n\r\n  // adding listeners\r\n  _addEventListener() {\r\n    const onSwipeStart = (e) => {\r\n      this._autoplay('stop');\r\n      if (e.target.closest(`.${this.constructor.EL_CONTROL}`)) {\r\n        return;\r\n      }\r\n      const event = e.type.search('touch') === 0 ? e.touches[0] : e;\r\n      this._swipeStartPosX = event.clientX;\r\n      this._swipeStartPosY = event.clientY;\r\n      this._hasSwipeState = true;\r\n      this._hasSwiping = false;\r\n    };\r\n    const onSwipeMove = (e) => {\r\n      if (!this._hasSwipeState) {\r\n        return;\r\n      }\r\n      const event = e.type.search('touch') === 0 ? e.touches[0] : e;\r\n      let diffPosX = this._swipeStartPosX - event.clientX;\r\n      const diffPosY = this._swipeStartPosY - event.clientY;\r\n      if (!this._hasSwiping) {\r\n        if (Math.abs(diffPosY) > Math.abs(diffPosX) || Math.abs(diffPosX) === 0) {\r\n          this._hasSwipeState = false;\r\n          return;\r\n        }\r\n        this._hasSwiping = true;\r\n      }\r\n      e.preventDefault();\r\n      if (!this._config.loop) {\r\n        const isNotMoveFirst = this._states[0] && diffPosX <= 0;\r\n        const isNotMoveLast = this._states[this._states.length - 1] && diffPosX >= 0;\r\n        if (isNotMoveFirst || isNotMoveLast) {\r\n          diffPosX /= 4;\r\n        }\r\n      }\r\n      this._elItems.classList.add(this.constructor.TRANSITION_NONE);\r\n      const valueX = this._transform * this._clientRect.width - diffPosX;\r\n      this._elItems.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n    };\r\n    const onSwipeEnd = (e) => {\r\n      if (!this._hasSwipeState) {\r\n        return;\r\n      }\r\n      const event = e.type.search('touch') === 0 ? e.changedTouches[0] : e;\r\n      let diffPosX = this._swipeStartPosX - event.clientX;\r\n      if (diffPosX === 0) {\r\n        this._hasSwipeState = false;\r\n        return;\r\n      }\r\n      if (!this._config.loop) {\r\n        const isNotMoveFirst = this._states[0] && diffPosX <= 0;\r\n        const isNotMoveLast = this._states[this._states.length - 1] && diffPosX >= 0;\r\n        if (isNotMoveFirst || isNotMoveLast) {\r\n          diffPosX = 0;\r\n        }\r\n      }\r\n      const value = (diffPosX / this._clientRect.width) * 100;\r\n      this._elItems.classList.remove(this.constructor.TRANSITION_NONE);\r\n      if (value > this.constructor.SWIPE_THRESHOLD) {\r\n        this._direction = 'next';\r\n        this._move();\r\n      } else if (value < -this.constructor.SWIPE_THRESHOLD) {\r\n        this._direction = 'prev';\r\n        this._move();\r\n      } else {\r\n        this._direction = 'none';\r\n        this._move();\r\n      }\r\n      this._hasSwipeState = false;\r\n      this._autoplay();\r\n    };\r\n    // click\r\n    this._el.addEventListener('click', (e) => {\r\n      const $target = e.target;\r\n      this._autoplay('stop');\r\n      if ($target.classList.contains(this.constructor.EL_CONTROL)) {\r\n        e.preventDefault();\r\n        this._direction = $target.dataset.slide;\r\n        this._move();\r\n      } else if ($target.dataset.slideTo) {\r\n        e.preventDefault();\r\n        const index = parseInt($target.dataset.slideTo, 10);\r\n        this._moveTo(index);\r\n      }\r\n      this._autoplay();\r\n    });\r\n\r\n    // transitionstart and transitionend\r\n    if (this._config.loop) {\r\n      this._elItems.addEventListener('transitionend', () => {\r\n        this._isBalancing = false;\r\n      });\r\n    }\r\n    // mouseenter and mouseleave\r\n    this._el.addEventListener('mouseenter', () => {\r\n      this._autoplay('stop');\r\n    });\r\n    this._el.addEventListener('mouseleave', () => {\r\n      this._autoplay();\r\n    });\r\n    // swipe\r\n    if (this._config.swipe) {\r\n      const options = this.constructor.checkSupportPassiveEvents() ? { passive: false } : false;\r\n      this._el.addEventListener('touchstart', onSwipeStart, options);\r\n      this._el.addEventListener('touchmove', onSwipeMove, options);\r\n      this._el.addEventListener('mousedown', onSwipeStart);\r\n      this._el.addEventListener('mousemove', onSwipeMove);\r\n      document.addEventListener('touchend', onSwipeEnd);\r\n      document.addEventListener('mouseup', onSwipeEnd);\r\n      document.addEventListener('mouseout', onSwipeEnd);\r\n    }\r\n    this._el.addEventListener('dragstart', (e) => {\r\n      e.preventDefault();\r\n    });\r\n    // при изменении активности вкладки\r\n    document.addEventListener('visibilitychange', () => {\r\n      if (document.visibilityState === 'visible' && this._config.loop) {\r\n        this._autoplay();\r\n      } else {\r\n        this._autoplay('stop');\r\n      }\r\n    });\r\n    if (this._supportResizeObserver) {\r\n      const resizeObserver = new ResizeObserver((entries) => {\r\n        const { contentRect } = entries[0];\r\n        if (Math.round(this._clientRect.width * 10) === Math.round(contentRect.width * 10)) {\r\n          return;\r\n        }\r\n        this._clientRect = contentRect;\r\n        const newValueX = contentRect.width * Number(this._elItems.dataset.translate);\r\n        this.reset(newValueX, true);\r\n        this._autoplay();\r\n      });\r\n      resizeObserver.observe(this._elWrapper);\r\n    }\r\n  }\r\n\r\n  reset(newValueX = 0, recalc = false) {\r\n    this._autoplay('stop');\r\n    this._elItems.classList.add(this.constructor.TRANSITION_NONE);\r\n    this._elItems.style.transform = `translate3D(${newValueX}px, 0px, 0.1px)`;\r\n    this._elListItem.forEach((el) => {\r\n      const valueX = recalc ? Number(el.dataset.translate) * this._clientRect.width : 0;\r\n      el.style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n    });\r\n    if (!recalc) {\r\n      this._transform = 0;\r\n      this._states = [];\r\n      this._elItems.dataset.translate = '0';\r\n      this._elListItem = this._el.querySelectorAll(`.${this.constructor.EL_ITEM}`);\r\n      // добавляем к слайдам data-атрибуты\r\n      this._elListItem.forEach((item, index) => {\r\n        item.dataset.order = `${index}`;\r\n        item.dataset.index = `${index}`;\r\n        item.dataset.translate = '0';\r\n        this._states.push(index === 0 ? 1 : 0);\r\n      });\r\n      // перемещаем последний слайд перед первым\r\n      if (this._config.loop) {\r\n        const count = this._elListItem.length - 1;\r\n        const translate = -this._elListItem.length;\r\n        this._elListItem[count].dataset.order = '-1';\r\n        this._elListItem[count].dataset.translate = `${-this._elListItem.length}`;\r\n        const valueX = translate * this._clientRect.width;\r\n        this._elListItem[count].style.transform = `translate3D(${valueX}px, 0px, 0.1px)`;\r\n      }\r\n      this._el.querySelector(`.${this.constructor.EL_INDICATORS}`).remove();\r\n      // добавляем индикаторы к слайдеру\r\n      this._addIndicators();\r\n      this._elListIndicator = document.querySelectorAll(`.${this.constructor.EL_INDICATOR}`);\r\n      // обновляем экстремальные значения переменных\r\n      this._updateExProperties();\r\n      // помечаем активные элементы\r\n      this._changeActiveItems();\r\n    }\r\n    this._autoplay();\r\n  }\r\n\r\n  // перейти к следующему слайду\r\n  next() {\r\n    this._direction = 'next';\r\n    this._move();\r\n  }\r\n  // перейти к предыдущему слайду\r\n  prev() {\r\n    this._direction = 'prev';\r\n    this._move();\r\n  }\r\n  // управление автоматической сменой слайдов\r\n  autoplay() {\r\n    this._autoplay('stop');\r\n  }\r\n  moveTo(index) {\r\n    this._moveTo(index);\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack://gulp2022/./src/js/modules/simple-adaptive-slider.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/app.js");
/******/ 	
/******/ })()
;